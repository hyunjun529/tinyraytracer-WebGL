<!DOCTYPE html>
<html lang="ko">
<head>
    <title>tinyraytracer-WebGL</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,
                                   user-scalable=no,
                                   minimum-scale=1.0,
                                   maximum-scale=1.0">
    <link rel="stylesheet" type="text/css" href="style.css">
</head>
<body>
    <h1>tinyraytracer</h1>
    
    <div id="cvs-0-wrapper">
        <canvas id="cvs-0" width="1024" height="768"></canvas>
    </div>

    <script type="text/javascript" src="webgl-math.js"></script>
    <script type="text/javascript" src="webgl-utils.js"></script>
    <script type="text/javascript" src="webgl-setup.js"></script>

    <script>
    //=========================================================================
    // Step 1: write an image to the disk
    //=========================================================================
    const width = 1024;
    const height = 768;

    var frameBuffer = new FrameBuffer( width, height );

    // set background
    for (var j = 0; j < height; j++) {
        for (var i = 0; i < width; i++) {
            let color = new Vector3(
                    (i / height),
                    (j / width),
                    0.5
                );
            frameBuffer.setPixelVector3(i, j, color);
        }
    }


    //=========================================================================
    // Step 2, the crucial one: ray tracing
    //=========================================================================
    const fov = Math.PI / 2.0;

    function Sphere( c, r, m ) {
        this.center = c;
        this.radius = r;
        this.material = m;
    };

    Object.assign( Sphere.prototype, {

        ray_intersect: function( orig, dir ) {
            let L = this.center.sub( orig );
            let tca = L.dot( dir );
            let d2 = L.dot( L ) - tca * tca;
            if ( d2 > this.radius * this.radius ) { 
                return { chk: false, dist: Number.MAX_VALUE } 
            };
            let thc = Math.sqrt(this.radius * this.radius - d2);
            let t0 = tca - thc;
            let t1 = tca + thc;
            if ( t0 < 0 ) t0 = t1;
            if ( t0 < 0 ) return { chk: false, dist: Number.MAX_VALUE };
            return { chk: true, dist: t0 };
        },

    } );

    // i give up, because original used too many Call by Reference,
    // so i also decide to use returning an object.
    function cast_ray( orig, dir, spheres ) {
        var result = scene_intersect( orig, dir, spheres );

        if( !result.chk ) {
            return new Vector3(0.2, 0.7, 0.8); // background color
        }

        return result.material.getDiffuse();
    }


    //=========================================================================
    // Step 3: add more spheres
    //=========================================================================
    const matIvony = new Material( 0.4, 0.4, 0.3 );
    const matRedRubber = new Material( 0.3, 0.1, 0.1 );

    function Material( r, g, b ) {

        this.diffuse_color = new Vector3( r, g, b );

    }

    Object.assign( Material.prototype, {

        getDiffuse: function() {
            return this.diffuse_color;
        },

        setDiffuse: function( r, g, b ) {
            this.diffuse_color.x = r;
            this.diffuse_color.y = g;
            this.diffuse_color.z = b;
        },

    } );

    function scene_intersect( orig, dir, spheres ) {
        var sphere_dist = Number.MAX_VALUE;
        var finalMaterial;

        for( var i = 0; i < spheres.length; i++ ) {
            var result = spheres[i].ray_intersect( orig, dir );
            if ( result.chk && result.dist < sphere_dist ) {
                sphere_dist = result.dist;
                // hit?
                // N?
                finalMaterial = spheres[i].material;
            }
        }

        // need check, is finalMaterial Null?

        return { chk: sphere_dist < 1000, material: finalMaterial };
    }

    //=========================================================================
    // Step 4: lighting
    //=========================================================================

    //=========================================================================
    // Step 5: specular lighting
    //=========================================================================

    //=========================================================================
    // Step 6: shadows
    //=========================================================================

    //=========================================================================
    // Step 7: reflections
    //=========================================================================

    //=========================================================================
    // Step 8: refractions
    //=========================================================================

    //=========================================================================
    // Steo 9: beyond the spheres
    //=========================================================================

    //=========================================================================
    // Step 10: home assignment
    //=========================================================================

    //=========================================================================
    // render (set FrameBuffer)
    //=========================================================================

    var sphere1 = new Sphere( new Vector3(-3.0,  0.0, -16), 2, matIvony );
    var sphere2 = new Sphere( new Vector3(-1.0, -1.5, -12), 2, matRedRubber );
    var sphere3 = new Sphere( new Vector3( 1.5, -0.5, -18), 3, matRedRubber );
    var sphere4 = new Sphere( new Vector3( 7.0,  5.0, -18), 4, matIvony );

    var spheres = [ sphere1, sphere2, sphere3, sphere4 ];

    for (var j = 0; j < height; j++) {
        for (var i = 0; i < width; i++) {
            var x = ( 2 * (i + 0.5) / width - 1)
                    * Math.tan(fov / 2.0)
                    * width / height;
 
            var y = -(2 * (j + 0.5) / height - 1)
                    * Math.tan(fov / 2.0);

            var dir = new Vector3(x, y, -1).normalize();

            var color = cast_ray( new Vector3(0, 0, 0), dir, spheres );

            frameBuffer.setPixelVector3( j, i, color );
        }
    }

    render(frameBuffer);
    
    </script>
</body>
</html>
