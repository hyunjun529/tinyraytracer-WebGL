<!DOCTYPE html>
<html lang="ko">
<head>
    <title>tinyraytracer-WebGL</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link rel="stylesheet" type="text/css" href="style.css">
</head>
<body>
    <h1>tinyraytracer</h1>
    
    <div id="cvs-0-wrapper">
        <canvas id="cvs-0" width="1024" height="768"></canvas>
    </div>

    <script type="text/javascript" src="webgl-math.js"></script>
    <script type="text/javascript" src="webgl-utils.js"></script>
    <script type="text/javascript" src="webgl-setup.js"></script>

    <script>
    //=========================================================================
    // Step 1: write an image to the disk
    //=========================================================================
    const width = 1024;
    const height = 768;

    var frameBuffer = new FrameBuffer( width, height );

    // set background
    for (var j = 0; j < height; j++) {
        for (var i = 0; i < width; i++) {
            let color = new Vector3(
                    (i / height),
                    (j / width),
                    0.5
                );
            frameBuffer.setPixelVector3(i, j, color);
        }
    }

    //=========================================================================
    // Step 2, the crucial one: ray tracing
    //=========================================================================
    const fov = Math.PI / 2.0;

    function Sphere( c, r ) {
        this.center = c;
        this.radius = r;
    };

    Object.assign( Sphere.prototype, {

        // t0?
        ray_intersect: function( orig, dir ) {
            let L = this.center.sub( orig );
            let tca = L.dot( dir );
            let d2 = L.dot( L ) - tca * tca;
            if ( d2 > this.radius * this.radius ) return false;
            let thc = Math.sqrt(this.radius * this.radius - d2);
            let t0 = tca - thc;
            let t1 = tca + thc;
            if ( t0 < 0 ) t0 = t1;
            if ( t0 < 0 ) return false; 
            return true;
        },

    } );

    function cast_ray( orig, dir, sphere ) {
        if( !sphere.ray_intersect( orig, dir ) ) {
            return new Vector3(0.2, 0.7, 0.8); // background color
        }
        return new Vector3(0.4, 0.4, 0.4);
    }

    //=========================================================================
    // Step 3: add more spheres
    //=========================================================================

    //=========================================================================
    // Step 4: lighting
    //=========================================================================

    //=========================================================================
    // Step 5: specular lighting
    //=========================================================================

    //=========================================================================
    // Step 6: shadows
    //=========================================================================

    //=========================================================================
    // Step 7: reflections
    //=========================================================================

    //=========================================================================
    // Step 8: refractions
    //=========================================================================

    //=========================================================================
    // Steo 9: beyond the spheres
    //=========================================================================

    //=========================================================================
    // Step 10: home assignment
    //=========================================================================

    //=========================================================================
    // render (set FrameBuffer)
    //=========================================================================
    var sphere1 = new Sphere( new Vector3(-3, 0, -16), 2);

    for (var j = 0; j < height; j++) {
        for (var i = 0; i < width; i++) {
            var x = ( 2 * (i + 0.5) / width - 1)
                    * Math.tan(fov / 2.0)
                    * width / height;
 
            var y = -(2 * (j + 0.5) / height - 1)
                    * Math.tan(fov / 2.0);

            var dir = new Vector3(x, y, -1).normalize();

            var color = cast_ray( new Vector3(0, 0, 0), dir, sphere1 );

            frameBuffer.setPixelVector3( j, i, color );
        }
    }

    render(frameBuffer);
    
    </script>
</body>
</html>
